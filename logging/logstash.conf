# Logstash Configuration for Deeper Bible API Log Processing

input {
  # Beats input (Filebeat)
  beats {
    port => 5044
  }
  
  # Direct TCP input for applications
  tcp {
    port => 5000
    codec => json_lines
  }
  
  # Syslog input
  syslog {
    port => 5140
  }
}

filter {
  # Parse JSON logs
  if [message] =~ /^\{.*\}$/ {
    json {
      source => "message"
      target => "parsed"
    }
    
    if [parsed] {
      mutate {
        add_field => {
          "log_level" => "%{[parsed][level]}"
          "log_message" => "%{[parsed][message]}"
          "timestamp" => "%{[parsed][@timestamp]}"
        }
      }
    }
  }
  
  # Parse application-specific log formats
  if [service] == "deeper-bible-api" {
    # Parse API request logs
    if [message] =~ /^\[API\]/ {
      grok {
        match => { 
          "message" => "\[API\] %{WORD:http_method} %{URIPATH:endpoint} - %{NUMBER:status_code:int} - %{NUMBER:response_time:float}ms - %{IP:client_ip}"
        }
        add_tag => ["api_request"]
      }
    }
    
    # Parse database query logs
    else if [message] =~ /^\[DB\]/ {
      grok {
        match => { 
          "message" => "\[DB\] %{WORD:query_type} - %{NUMBER:duration:float}ms - %{GREEDYDATA:query}"
        }
        add_tag => ["database_query"]
      }
    }
    
    # Parse authentication logs
    else if [message] =~ /^\[AUTH\]/ {
      grok {
        match => { 
          "message" => "\[AUTH\] %{WORD:auth_action} - %{WORD:auth_result} - %{DATA:user_id} - %{IP:client_ip}"
        }
        add_tag => ["authentication"]
      }
    }
    
    # Parse error logs
    else if [log_level] == "error" or [level] == "error" {
      mutate {
        add_tag => ["error"]
      }
      
      # Extract stack trace if present
      if [message] =~ /Error: / {
        grok {
          match => { 
            "message" => "Error: %{DATA:error_message}(\n|\r\n)%{GREEDYDATA:stack_trace}"
          }
        }
      }
    }
  }
  
  # Parse Docker container logs
  if [container] {
    mutate {
      add_field => {
        "container_name" => "%{[container][name]}"
        "container_image" => "%{[container][image]}"
        "container_id" => "%{[container][id]}"
      }
    }
  }
  
  # GeoIP lookup for client IPs
  if [client_ip] {
    geoip {
      source => "client_ip"
      target => "geoip"
    }
  }
  
  # Add environment and service information
  mutate {
    add_field => {
      "environment" => "${ENV:production}"
      "service_name" => "deeper-bible-api"
      "log_type" => "application"
    }
  }
  
  # Parse timestamp
  if [timestamp] {
    date {
      match => [ "timestamp", "ISO8601" ]
      target => "@timestamp"
    }
  }
  
  # Remove unnecessary fields
  mutate {
    remove_field => ["agent", "ecs", "log", "input", "host"]
  }
  
  # Add severity level based on log level
  if [log_level] == "error" or [level] == "error" {
    mutate {
      add_field => { "severity" => "high" }
    }
  } else if [log_level] == "warn" or [level] == "warn" {
    mutate {
      add_field => { "severity" => "medium" }
    }
  } else {
    mutate {
      add_field => { "severity" => "low" }
    }
  }
}

output {
  # Output to Elasticsearch
  elasticsearch {
    hosts => ["elasticsearch:9200"]
    index => "deeper-bible-logs-%{+yyyy.MM.dd}"
    
    # Use different indices for different log types
    if "api_request" in [tags] {
      index => "deeper-bible-api-requests-%{+yyyy.MM.dd}"
    } else if "database_query" in [tags] {
      index => "deeper-bible-database-%{+yyyy.MM.dd}"
    } else if "authentication" in [tags] {
      index => "deeper-bible-auth-%{+yyyy.MM.dd}"
    } else if "error" in [tags] {
      index => "deeper-bible-errors-%{+yyyy.MM.dd}"
    }
    
    template_name => "deeper-bible-logs"
    template => "/usr/share/logstash/templates/deeper-bible-template.json"
    template_overwrite => true
  }
  
  # Debug output (remove in production)
  # stdout { codec => rubydebug }
}

# Index lifecycle management
# PUT _ilm/policy/deeper-bible-logs-policy
# {
#   "policy": {
#     "phases": {
#       "hot": {
#         "actions": {
#           "rollover": {
#             "max_size": "10GB",
#             "max_age": "7d"
#           }
#         }
#       },
#       "warm": {
#         "min_age": "7d",
#         "actions": {
#           "allocate": {
#             "number_of_replicas": 0
#           }
#         }
#       },
#       "delete": {
#         "min_age": "30d"
#       }
#     }
#   }
# }